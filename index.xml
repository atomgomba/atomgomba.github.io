<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

  <channel>
    <title>mémgyár</title>
    <link>/</link>
    <description>Recent content on mémgyár</description>
    
    <language>en</language>
    <lastBuildDate>Wed, 25 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data classes and compiler safety</title>
      <link>/blog/en/defaults-in-data-classes/</link>
      <category>kotlin</category>
      <category>patterns</category>
      <category>best-practices</category><pubDate>Wed, 25 Feb 2026 00:00:00 +0000</pubDate>
      
      <guid>/blog/en/defaults-in-data-classes/</guid>
      <description>When adding a new property to an existing data class, the compiler can warn us when we forget to initialize its value somewhere in the codebase. But it can only help if the new property does not have a default value: without the help from the compiler, it is very easy to miss an unset value, particularly in large code bases! Going through all the places where the property is used also gives us a valuable chance to revisit the business logic and think about why and where it is used.</description>
    </item>
    
    <item>
      <title>Using tags with Timber</title>
      <link>/blog/en/timber-tags/</link>
      <category>kotlin</category>
      <category>logging</category><pubDate>Thu, 22 May 2025 00:00:00 +0000</pubDate>
      
      <guid>/blog/en/timber-tags/</guid>
      <description>The Android logging functions (the methods of the Log class) accept a tag argument that can be used to identify the source of the log message. It is common practice to use a constant to define this tag, like in the following example:
class Frobnicator { fun frobnicate() { Log.d(TAG, &amp;#34;Executing frobnicate&amp;#34;) } fun fooBar() { Log.d(TAG, &amp;#34;Executing fooBar&amp;#34;) } companion object { private val TAG: String = Frobnicator::class.simpleName!! } } Setting a tag can be achieved in Timber by using the tag() method, for instance:</description>
    </item>
    
    <item>
      <title>Publishing to Maven Central in 2025</title>
      <link>/blog/en/publishing-to-maven-central/</link>
      <category>publishing</category>
      <category>guide</category><pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>/blog/en/publishing-to-maven-central/</guid>
      <description>The process of publishing artifacts to Maven Central Repository is well documented, but important information are scattered throughout the web and there are some caveats. This guide focuses on publishing a library using Gradle. The steps will be the same for Java, Kotlin (also Multiplatform) and Android projects as well. This is not a complete guide, rather a collection of gotchas I couldn&amp;rsquo;t find anywhere else; for the rest of the steps just follow the official guides.</description>
    </item>
    
    <item>
      <title>Decoration in Kotlin</title>
      <link>/blog/en/decoration-in-kotlin/</link>
      <category>kotlin</category>
      <category>patterns</category>
      <category>best-practices</category><pubDate>Sun, 02 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>/blog/en/decoration-in-kotlin/</guid>
      <description>When I&amp;rsquo;m bumping into an interface with only one implementation, it makes me think of reasons why is that interface even needed?
Common arguments Interfaces are good for many things: promote code re-use by abstraction, help define boundaries in architecture, provide a form of multiple inheritance and so on, but usually a common argument for using them is that they make it easy to swap implementations, thus they also help with testing.</description>
    </item>
    
  </channel>
</rss>
